{"version":3,"sources":["webpack:///webpack/bootstrap b63831e5839f817c27c2","webpack:///./lib/canvas_tiles.js","webpack:///./lib/game.js","webpack:///./lib/board.js","webpack:///./lib/game_view.js","webpack:///./lib/tile.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;AClCD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA,mBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA,oBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACrFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,eAAe;AAChC;AACA,mBAAkB,eAAe;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,eAAe;AAChC,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAiD,OAAO;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAoC,4DAA4D;AAChG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAiB,eAAe;AAChC,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,eAAe;AAChC,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7DA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b63831e5839f817c27c2\n **/","const Game = require(\"./game\");\nconst GameView = require(\"./game_view\");\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  // ES6, not universally supported\n  // [tileCanvas, bkgdCanvas = document.getElementsByTagName(\"canvas\");\n\n  document.getElementById(\"slider\").onchange = function(  ) {\n    document.getElementById(\"sliderVal\").textContent = this.value;\n  };\n\n  const bkgdCanvas = document.getElementsByClassName(\"background\")[0];\n  const tileCanvas = document.getElementsByClassName(\"tiles\")[0];\n\n  const bkgdCtx = bkgdCanvas.getContext(\"2d\");\n  const tileCtx = tileCanvas.getContext(\"2d\");\n\n  tileCtx.font = \"bold 48px Arial\";\n  tileCtx.textBaseline = \"middle\";\n  tileCtx.textAlign = \"center\";\n\n  const buttons = document.getElementsByClassName(\"new-game-button\")\n  for (let i = 0; i < buttons.length; i++) {\n    buttons[i].textContent = Game.GAME_TYPES[i];\n    buttons[i].onclick = function() {\n      const size = document.getElementsByTagName(\"input\")[0].value;\n      game.newGame(size - 0, Game.GAME_TYPES[i], bkgdCtx);\n      gameView.animate();\n    }\n  }\n\n  const game = new Game(bkgdCtx);\n  const gameView = new GameView(game, tileCtx)\n  gameView.start();\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/canvas_tiles.js\n ** module id = 0\n ** module chunks = 0\n **/","const Board = require('./board');\n\nfunction resizeCanvas(width, height) {\n  const bkgdCanvas = document.getElementsByClassName(\"background\")[0];\n  const tileCanvas = document.getElementsByClassName(\"tiles\")[0];\n\n  // canvas container doesn't automatically resize\n  document.getElementsByClassName(\"board\").item(0).style.height = height;\n\n  bkgdCanvas.width = width;\n  bkgdCanvas.height = height;\n\n  tileCanvas.width = width;\n  tileCanvas.height = height;\n\n  // .width resets these properties\n  const tileCtx = tileCanvas.getContext(\"2d\");\n  tileCtx.font = \"bold 48px Arial\";\n  tileCtx.textBaseline = \"middle\";\n  tileCtx.textAlign = \"center\";\n}\n\nconst Game = function(bkgd) {\n  this.newGame(4, \"CLASSIC\", bkgd);\n};\n\nGame.GAME_TYPES = [\"CLASSIC\", \"PRIMES\"];\n\nGame.prototype.newGame = function (size, gameType, bkgd) {\n  if (size > 6) {\n    resizeCanvas(600, 600);\n  } else {\n    resizeCanvas(size * 100, size * 100);\n  }\n\n  this.board = new Board(size, gameType, this.addScore.bind(this));\n  this.board.drawBkgd(bkgd);\n\n  this.score = 0;\n  this.over = false;\n  this.initialTiles(Math.floor(Math.sqrt(size)));\n};\n\nGame.prototype.initialTiles = function (count) {\n  for (let i = 0; i < count; i++) {\n    this.board.setRandomTile();\n  }\n};\n\nGame.prototype.moveTiles = function (delta) {\n  if (this.over) { return }\n\n  // unclear if this is helping or not\n  this.board.snapTiles();\n  this.board.clearTempTiles();\n\n  const moved = this.board.moveTiles(delta);\n\n  if (moved) {\n    for (let i = 0; i < Math.floor(this.board.size / 4); i++) {\n      if (this.board.count() < this.board.max) {\n        this.board.setRandomTile();\n      }\n    }\n  }\n\n  if (!this.board.movePossible()) {\n    this.over = true;\n    setTimeout(() => {\n      alert(\"No moves possible. Game over.\");\n    }, 2000)\n  }\n\n  return moved;\n};\n\nGame.prototype.addScore = function (amount) {\n  this.score += amount;\n};\n\nGame.prototype.draw = function (ctx) {\n  this.board.updateTiles();\n  this.board.draw(ctx);\n};\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game.js\n ** module id = 1\n ** module chunks = 0\n **/","const Tile = require('./tile');\n\nconst Board = function (size, type, scoreCallback) {\n  this.size = size;\n  this.type = type;\n  this.tiles = [];\n  this.tempTiles = [];\n  this.scoreCallback = scoreCallback;\n  this.stepSize = Math.floor(size / 4) / 2;\n  this.max = this.size * this.size;\n\n  if (size > 6) {\n    this.dim_x = 600;\n    this.dim_y = 600;\n    this.margin = Math.floor(100 / (size + 1));\n    this.tileDim_x = (600 - ((size + 1) * this.margin)) / size;\n    this.tileDim_y = (600 - ((size + 1) * this.margin)) / size;\n  } else {\n    this.dim_x = size * 100;\n    this.dim_y = size * 100;\n    this.margin = 16;\n    this.tileDim_x = (this.dim_x - ((size + 1) * 16)) / size;\n    this.tileDim_y = (this.dim_y - ((size + 1) * 16)) / size;\n  }\n};\n\nBoard.SEEDS = { \"CLASSIC\": [2, 4],\n                 \"PRIMES\": [2, 3] };\n\nBoard.prototype.count = function () {\n  return this.tiles.length;\n};\n\nBoard.prototype.emptyGrid = function () {\n  const grid = [];\n  let row = [];\n\n  for (let i = 0; i < this.size; i++) {\n   row = [];\n   for (let j = 0; j < this.size; j++) {\n     row.push(null);\n   }\n   grid.push(row);\n  }\n\n  return grid;\n};\n\nBoard.prototype.drawBkgd = function (bkgd) {\n  bkgd.clearRect(0, 0, this.dim_x, this.dim_y);\n  bkgd.fillStyle = \"rgba(238, 228, 218, .35)\";\n\n  for (let i = 0; i < this.size; i++) {\n    for (let j = 0; j < this.size; j++) {\n      bkgd.fillRect((i + 1) * this.margin + i * this.tileDim_x,\n                    (j + 1) * this.margin + j * this.tileDim_y,\n                    this.tileDim_x, this.tileDim_y);\n    }\n  }\n};\n\nBoard.prototype.debugSetup = function () {\n  let pos;\n  for (let i = this.size * this.size - this.size; i > 0; i--) {\n    this.setRandomTile();\n  }\n};\n\nBoard.prototype.removeTile = function (tile) {\n  this.tiles.splice(this.tiles.indexOf(tile), 1);\n};\n\nBoard.prototype.getTile = function (pos) {\n  return this.tiles.find((tile) => { return (tile.pos[0] === pos[0] && tile.pos[1] === pos[1]) } );\n};\n\nBoard.prototype.setTile = function (tile) {\n  this.tiles.push(tile);\n};\n\nBoard.prototype.mergeTile = function (tile) {\n  this.scoreCallback(tile.merge(this.nextValue.bind(this)));\n};\n\n// for merging\n// remove tile from tiles array\n// add tile to temporary tiles\nBoard.prototype.pseudify = function (tile) {\n  this.removeTile(tile);\n  this.tempTiles.push(tile);\n};\n\nBoard.prototype.allTiles = function () {\n  return this.tiles;\n};\n\nBoard.prototype.updateTiles = function () {\n  this.tempTiles.concat(this.tiles).forEach((tile) => {\n    tile.step(this.stepSize)\n  });\n};\n\n// snap tiles to target\nBoard.prototype.snapTiles = function () {\n  this.tiles.forEach((tile) => {\n    tile.snap();\n  })\n};\n\nBoard.prototype.clearTempTiles = function () {\n  this.tempTiles = [];\n};\n\nBoard.prototype.moveTiles = function (direction) {\n  let col;\n  let firstMovablePos;\n  let newPos = [0, 0];\n  let moved = false;\n\n  // create a grid to help ensure we iterate over the tiles in the correct order\n  const grid = this.emptyGrid();\n  this.tiles.forEach((tile) => {\n    grid[tile.pos[0]][tile.pos[1]] = tile;\n  });\n\n  if (direction[0] === 1) {\n    grid.reverse();\n  }\n\n  grid.forEach((column) => {\n    col = column.slice();\n    if (direction[1] === 1) {\n      col.reverse();\n    }\n\n    col.forEach((tile) => {\n      if (!tile) { return; }\n      tile.merged = false;\n      firstMovablePos = this.firstMovablePos(tile.pos, direction);\n\n      if (firstMovablePos[0] !== tile.pos[0] || firstMovablePos[1] !== tile.pos[1]) {\n        moved = true;\n        this.moveTile(tile.pos, firstMovablePos);\n      }\n    });\n  });\n\n  return moved;\n};\n\n// return position of nearest free space or mergable tile\nBoard.prototype.firstMovablePos = function (pos, direction) {\n  let nextPos = [pos[0] + direction[0], pos[1] + direction[1]];\n  let nextTile;\n\n  while (this.inBounds(nextPos)) {\n    nextTile = this.getTile(nextPos)\n    if (nextTile) {\n      if (Tile.canMerge(this.getTile(nextPos), this.getTile(pos))) {\n        nextPos = [nextPos[0] + direction[0], nextPos[1] + direction[1]];\n        break;\n      } else {\n        break;\n      }\n    }\n    nextPos = [nextPos[0] + direction[0], nextPos[1] + direction[1]];\n  }\n\n  return [nextPos[0] - direction[0], nextPos[1] - direction[1]];\n};\n\nBoard.prototype.inBounds = function (pos) {\n  return pos[0] >= 0 && pos[0] < this.size && pos[1] >= 0 && pos[1] < this.size;\n};\n\nBoard.prototype.moveTile = function (pos, newPos) {\n  const tile = this.getTile(pos);\n  const existingTile = this.getTile(newPos);\n\n  if (existingTile) {\n    this.mergeTile(existingTile);\n    tile.moveTo(newPos);\n    this.pseudify(tile);\n  } else {\n    this.removeTile(tile);\n    tile.moveTo(newPos);\n    this.setTile(tile);\n  }\n};\n\nBoard.prototype.nextValue = function (value) {\n  switch (this.type) {\n    case \"PRIMES\":\n      return nextPrime(value);\n      break;\n    case \"CLASSIC\":\n    default:\n      return value * 2;\n  }\n};\n\nBoard.prototype.setRandomTile = function () {\n  const pos = this.getRandomAvailablePosition();\n  const tile = new Tile(pos, Board.SEEDS[this.type][Math.random() > .9 ? 1 : 0]);\n  this.setTile(tile);\n};\n\nBoard.prototype.getRandomAvailablePosition = function () {\n  const availablePositions = this.availablePositions();\n\n  return availablePositions[Math.floor(Math.random() * availablePositions.length)]\n};\n\nBoard.prototype.availablePositions = function () {\n  const positions = [];\n\n  for (let i = 0; i < this.size; i++) {\n    for (let j = 0; j < this.size; j++) {\n      if (this.freeTile([i, j])) {\n        positions.push([i, j]);\n      }\n    }\n  }\n\n  return positions;\n};\n\nBoard.prototype.freeTile = function (pos) {\n  return !this.getTile(pos);\n};\n\nBoard.prototype.movePossible = function () {\n  let possible = false;\n  for (let i = 0; i < this.size; i++) {\n    for (let j = 0; j < this.size; j++) {\n      if (!this.getTile([i, j])) {\n        // not sure if returning here returns from the function or not\n        // in either case, this acheives the desired effect\n        possible = true;\n        return true;\n      }\n    }\n  }\n\n  if (possible) {\n    return true;\n  }\n\n  this.tiles.forEach((tile) => {\n    if (this.adjacentMergeableTile(tile)) {\n      possible = true;\n      return true;\n    }\n  });\n\n  return possible;\n};\n\nBoard.prototype.adjacentMergeableTile = function (tile) {\n  let found = false;\n\n  [[0, -1], [0, 1], [-1, 0], [1, 0]].map((dir) => {\n    return [tile.pos[0] + dir[0], tile.pos[1] + dir[1]];\n  }).forEach((pos) => {\n    if (this.inBounds(pos) && tile.value === this.getTile(pos).value) {\n      found = true;\n    }\n  })\n\n  return found;\n};\n\nBoard.prototype.draw = function (ctx) {\n  const tiles = this.allTiles();\n\n  ctx.clearRect(0, 0, this.dim_x, this.dim_y);\n\n  this.tempTiles.concat(this.tiles).forEach((tile) => {\n    tile.draw(ctx, this.margin, this.tileDim_x, this.tileDim_y);\n  });\n};\n\nfunction nextPrime(num) {\n  while (!isPrime(++num)) {}\n  return num;\n}\n\nfunction isPrime(num) {\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/board.js\n ** module id = 2\n ** module chunks = 0\n **/","const GameView = function (game, ctx) {\n  this.ctx = ctx;\n  this.game = game;\n  this.scoreEl = document.getElementsByClassName(\"score\")[0];\n  this.highScoreEl = document.getElementsByClassName(\"highscore\")[0];\n  this.animating = false;\n};\n\nGameView.KEYCODES = {\n  \"87\": [0, -1], // w\n  \"38\": [0, -1], // up\n  \"65\": [-1, 0], // a\n  \"37\": [-1, 0], // left\n  \"83\": [0, 1], // s\n  \"40\": [0, 1], // down\n  \"68\": [1, 0], // d\n  \"39\": [1, 0] // right\n};\n\nGameView.prototype.handleArrow = function (event) {\n  if (Object.keys(GameView.KEYCODES).includes(event.keyCode.toString())) {\n    event.preventDefault();\n\n    // returns true if a tile has moved\n    if (this.game.moveTiles(GameView.KEYCODES[event.keyCode])) {\n      this.updateScore();\n      this.startTime = performance.now();\n      if (!this.animating) {\n        this.animating = true;\n        requestAnimationFrame(this.animate.bind(this));\n      }\n    }\n  };\n};\n\nGameView.prototype.bindKeyHandlers = function () {\n  window.addEventListener(\"keydown\", this.handleArrow.bind(this) );\n};\n\nGameView.prototype.start = function () {\n  this.bindKeyHandlers();\n  requestAnimationFrame(this.animate.bind(this));\n};\n\nGameView.prototype.animate = function(time) {\n  this.game.draw(this.ctx);\n\n  if (time - this.startTime < 400) {\n    requestAnimationFrame(this.animate.bind(this));\n  } else {\n    this.animating = false;\n  }\n};\n\nGameView.prototype.updateScore = function () {\n  this.scoreEl.textContent = this.game.score;\n  if (this.game.score > this.highScoreEl.textContent) {\n    this.highScoreEl.textContent = this.game.score;\n  }\n};\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game_view.js\n ** module id = 3\n ** module chunks = 0\n **/","function findRGB(value) {\n  let coefficient = 1;\n\tlet rgb = [238, 229, 219];\n\n  if (value > 2048) {\n\t\tcoefficient = value / 16384;\n\t\trgb = [224 - Math.floor(coefficient * 144), 256, 165 - Math.floor(coefficient * 20)];\n\t}\telse if (value > 64) {\n\t\tcoefficient = value / 2048;\n\t\trgb = [237, 190 + Math.floor(coefficient * 20), 133 - Math.floor(coefficient * 80)];\n\t} else if (value > 4) {\n\t\tcoefficient = Math.pow(value / 64, .5);\n\t\trgb = [246, 224 - Math.floor(coefficient * 130), 189 - Math.floor(coefficient * 130)];\n\t} else if (value > 2) {\n\t\trgb = [237, 224, 200];\n\t}\n  return \"rgb(\" + rgb.join() + \")\";\n}\n\nconst Tile = function (pos, value) {\n  this.pos = pos;\n  this.drawPos = pos;\n\tthis.value = value;\n};\n\nTile.prototype.moveTo = function (pos) {\n\tthis.pos = pos;\n};\n\nTile.prototype.merge = function (nextValue) {\n\tthis.merged = true;\n\treturn this.value = nextValue(this.value);\n};\n\nTile.prototype.step = function (stepSize) {\n  let x = this.pos[0];\n  let y = this.pos[1];\n\n  let drawX = this.drawPos[0];\n  let drawY = this.drawPos[1];\n\n  if (drawX > x) {\n    if ((drawX -= stepSize) <= x) {\n      drawX = x;\n      this.drawPos = [drawX, drawY];\n      return true;\n    }\n  }\n\n  if (drawY > y) {\n    if ((drawY -= stepSize) <= y) {\n      drawY = y;\n      this.drawPos = [drawX, drawY];\n      return true;\n    }\n  }\n\n  if (drawX < x) {\n    if ((drawX += stepSize) >= x) {\n      drawX = x;\n      this.drawPos = [drawX, drawY];\n      return true;\n    }\n  }\n\n  if (drawY < y) {\n    if ((drawY += stepSize) >= y) {\n      drawY = y;\n      this.drawPos = [drawX, drawY];\n      return true;\n    }\n  }\n\n  this.drawPos = [drawX, drawY];\n  return false;\n};\n\nTile.prototype.snap = function () {\n  this.drawPos = this.pos;\n};\n\nTile.prototype.draw = function (ctx, margin, dim_x, dim_y) {\n  const fontSize = 56 - Math.ceil(Math.log(this.value) / Math.log(10)) * 8;\n  const textColor = this.value > 4 ? \"#f9f6f2\" : \"#776e65\";\n\n\tconst bgColor = findRGB(this.value);\n\n  const pos_x = (this.drawPos[0] + 1) * margin + this.drawPos[0] * dim_x;\n  const pos_y = (this.drawPos[1] + 1) * margin + this.drawPos[1] * dim_y;\n\n\tctx.save();\n\tctx.fillStyle = bgColor;\n\tctx.translate(pos_x, pos_y);\n  ctx.fillRect(0, 0, dim_x, dim_y);\n  ctx.fillStyle = textColor;\n  ctx.font = \"bold \" + fontSize + \"px Arial\";\n  ctx.fillText(this.value.toString(), dim_x / 2, dim_y / 2);\n\tctx.restore();\n};\n\nTile.canMerge = function (tile1, tile2) {\n  return tile1.value === tile2.value && !(tile1.merged || tile2.merged);\n}\n\nmodule.exports = Tile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/tile.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}